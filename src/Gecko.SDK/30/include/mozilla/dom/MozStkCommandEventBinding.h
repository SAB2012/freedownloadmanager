/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#ifndef mozilla_dom_MozStkCommandEventBinding_h__
#define mozilla_dom_MozStkCommandEventBinding_h__

#include "EventBinding.h"
#include "js/RootingAPI.h"
#include "jspubtd.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/Date.h"
#include "mozilla/dom/Nullable.h"

namespace mozilla {
namespace dom {

struct MozStkBipMessageAtoms;
struct MozStkBrowserSettingAtoms;
struct MozStkBrowserTerminationEventAtoms;
struct MozStkCallEventAtoms;
struct MozStkCommandAtoms;
class MozStkCommandEvent;
struct MozStkCommandEventInitAtoms;
struct MozStkDuration;
struct MozStkDurationAtoms;
struct MozStkGeneralEventAtoms;
struct MozStkInputAtoms;
struct MozStkItem;
struct MozStkItemAtoms;
struct MozStkLanguageSelectionEventAtoms;
struct MozStkLocalInfo;
struct MozStkLocalInfoAtoms;
struct MozStkLocationEventAtoms;
struct MozStkLocationInfo;
struct MozStkLocationInfoAtoms;
struct MozStkMenuAtoms;
struct MozStkPlayToneAtoms;
struct MozStkProvideLocalInfoAtoms;
struct MozStkResponseAtoms;
struct MozStkSetUpCallAtoms;
struct MozStkSetUpEventListAtoms;
struct MozStkTextMessage;
struct MozStkTextMessageAtoms;
struct MozStkTimer;
struct MozStkTimerAtoms;
class NativePropertyHooks;
class ProtoAndIfaceArray;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

struct MozStkBipMessage : public DictionaryBase
{
  Optional<nsString > mText;

  MozStkBipMessage();

  explicit inline MozStkBipMessage(const MozStkBipMessage& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkBipMessage(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkBipMessageAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkBipMessage& aOther);
};

namespace binding_detail {
struct FastMozStkBipMessage : public MozStkBipMessage
{
  inline FastMozStkBipMessage()
    : MozStkBipMessage(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkBrowserTerminationEvent : public DictionaryBase
{
  Optional<uint16_t > mEventType;
  Optional<uint16_t > mTerminationCause;

  MozStkBrowserTerminationEvent();

  explicit inline MozStkBrowserTerminationEvent(const MozStkBrowserTerminationEvent& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkBrowserTerminationEvent(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkBrowserTerminationEventAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkBrowserTerminationEvent& aOther);
};

namespace binding_detail {
struct FastMozStkBrowserTerminationEvent : public MozStkBrowserTerminationEvent
{
  inline FastMozStkBrowserTerminationEvent()
    : MozStkBrowserTerminationEvent(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkCallEvent : public DictionaryBase
{
  Optional<nsString > mError;
  Optional<uint16_t > mEventType;
  Optional<bool > mIsIssuedByRemote;
  Optional<nsString > mNumber;

  MozStkCallEvent();

  explicit inline MozStkCallEvent(const MozStkCallEvent& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkCallEvent(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkCallEventAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkCallEvent& aOther);
};

namespace binding_detail {
struct FastMozStkCallEvent : public MozStkCallEvent
{
  inline FastMozStkCallEvent()
    : MozStkCallEvent(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkCommand : public DictionaryBase
{
  Optional<uint16_t > mCommandNumber;
  Optional<uint16_t > mCommandQualifier;
  JS::Value mOptions;
  Optional<uint16_t > mTypeOfCommand;

  MozStkCommand();

protected:
  explicit inline MozStkCommand(int )
    : mOptions(JS::UndefinedValue())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  MozStkCommand(const MozStkCommand&) MOZ_DELETE;
  void operator=(const MozStkCommand) MOZ_DELETE;

  static bool
  InitIds(JSContext* cx, MozStkCommandAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastMozStkCommand : public MozStkCommand
{
  inline FastMozStkCommand()
    : MozStkCommand(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkCommandEventInit : public EventInit
{
  JS::Value mCommand;

  MozStkCommandEventInit();

protected:
  explicit inline MozStkCommandEventInit(int )
    : mCommand(JS::UndefinedValue())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  MozStkCommandEventInit(const MozStkCommandEventInit&) MOZ_DELETE;
  void operator=(const MozStkCommandEventInit) MOZ_DELETE;

  static bool
  InitIds(JSContext* cx, MozStkCommandEventInitAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastMozStkCommandEventInit : public MozStkCommandEventInit
{
  inline FastMozStkCommandEventInit()
    : MozStkCommandEventInit(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkDuration : public DictionaryBase
{
  Optional<uint8_t > mTimeInterval;
  Optional<uint16_t > mTimeUnit;

  MozStkDuration();

  explicit inline MozStkDuration(const MozStkDuration& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkDuration(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkDurationAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkDuration& aOther);
};

namespace binding_detail {
struct FastMozStkDuration : public MozStkDuration
{
  inline FastMozStkDuration()
    : MozStkDuration(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkGeneralEvent : public DictionaryBase
{
  Optional<uint16_t > mEventType;

  MozStkGeneralEvent();

  explicit inline MozStkGeneralEvent(const MozStkGeneralEvent& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkGeneralEvent(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkGeneralEventAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkGeneralEvent& aOther);
};

namespace binding_detail {
struct FastMozStkGeneralEvent : public MozStkGeneralEvent
{
  inline FastMozStkGeneralEvent()
    : MozStkGeneralEvent(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkItem : public DictionaryBase
{
  Optional<uint16_t > mIdentifier;
  Optional<nsString > mText;

  MozStkItem();

  explicit inline MozStkItem(const MozStkItem& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkItem(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkItemAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkItem& aOther);
};

namespace binding_detail {
struct FastMozStkItem : public MozStkItem
{
  inline FastMozStkItem()
    : MozStkItem(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkLanguageSelectionEvent : public DictionaryBase
{
  Optional<uint16_t > mEventType;
  Optional<nsString > mLanguage;

  MozStkLanguageSelectionEvent();

  explicit inline MozStkLanguageSelectionEvent(const MozStkLanguageSelectionEvent& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkLanguageSelectionEvent(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkLanguageSelectionEventAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkLanguageSelectionEvent& aOther);
};

namespace binding_detail {
struct FastMozStkLanguageSelectionEvent : public MozStkLanguageSelectionEvent
{
  inline FastMozStkLanguageSelectionEvent()
    : MozStkLanguageSelectionEvent(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkLocationInfo : public DictionaryBase
{
  Optional<uint32_t > mGsmCellId;
  Optional<uint16_t > mGsmLocationAreaCode;
  Optional<uint16_t > mMcc;
  Optional<uint16_t > mMnc;

  MozStkLocationInfo();

  explicit inline MozStkLocationInfo(const MozStkLocationInfo& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkLocationInfo(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkLocationInfoAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkLocationInfo& aOther);
};

namespace binding_detail {
struct FastMozStkLocationInfo : public MozStkLocationInfo
{
  inline FastMozStkLocationInfo()
    : MozStkLocationInfo(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkProvideLocalInfo : public DictionaryBase
{
  Optional<uint16_t > mLocalInfoType;

  MozStkProvideLocalInfo();

  explicit inline MozStkProvideLocalInfo(const MozStkProvideLocalInfo& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkProvideLocalInfo(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkProvideLocalInfoAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkProvideLocalInfo& aOther);
};

namespace binding_detail {
struct FastMozStkProvideLocalInfo : public MozStkProvideLocalInfo
{
  inline FastMozStkProvideLocalInfo()
    : MozStkProvideLocalInfo(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkSetUpEventList : public DictionaryBase
{
  Optional<Sequence<uint16_t > > mEventList;

  MozStkSetUpEventList();

  explicit inline MozStkSetUpEventList(const MozStkSetUpEventList& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkSetUpEventList(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkSetUpEventListAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkSetUpEventList& aOther);
};

namespace binding_detail {
struct FastMozStkSetUpEventList : public MozStkSetUpEventList
{
  inline FastMozStkSetUpEventList()
    : MozStkSetUpEventList(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkTimer : public DictionaryBase
{
  Optional<uint16_t > mTimerAction;
  Optional<uint8_t > mTimerId;
  Optional<uint32_t > mTimerValue;

  MozStkTimer();

  explicit inline MozStkTimer(const MozStkTimer& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkTimer(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkTimerAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkTimer& aOther);
};

namespace binding_detail {
struct FastMozStkTimer : public MozStkTimer
{
  inline FastMozStkTimer()
    : MozStkTimer(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkInput : public DictionaryBase
{
  Optional<nsString > mDefaultText;
  MozStkDuration mDuration;
  Optional<bool > mHideInput;
  Optional<bool > mIsAlphabet;
  Optional<bool > mIsHelpAvailable;
  Optional<bool > mIsPacked;
  Optional<bool > mIsUCS2;
  Optional<bool > mIsYesNoRequested;
  Optional<uint16_t > mMaxLength;
  Optional<uint16_t > mMinLength;
  Optional<nsString > mText;

  MozStkInput();

  explicit inline MozStkInput(const MozStkInput& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkInput(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkInputAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkInput& aOther);
};

namespace binding_detail {
struct FastMozStkInput : public MozStkInput
{
  inline FastMozStkInput()
    : MozStkInput(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkLocalInfo : public DictionaryBase
{
  Optional<Date > mDate;
  Optional<nsString > mImei;
  Optional<nsString > mLanguage;
  MozStkLocationInfo mLocationInfo;

  MozStkLocalInfo();

protected:
  explicit inline MozStkLocalInfo(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  MozStkLocalInfo(const MozStkLocalInfo&) MOZ_DELETE;
  void operator=(const MozStkLocalInfo) MOZ_DELETE;

  static bool
  InitIds(JSContext* cx, MozStkLocalInfoAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastMozStkLocalInfo : public MozStkLocalInfo
{
  inline FastMozStkLocalInfo()
    : MozStkLocalInfo(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkLocationEvent : public DictionaryBase
{
  Optional<uint16_t > mEventType;
  MozStkLocationInfo mLocationInfo;
  Optional<uint16_t > mLocationStatus;

  MozStkLocationEvent();

  explicit inline MozStkLocationEvent(const MozStkLocationEvent& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkLocationEvent(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkLocationEventAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkLocationEvent& aOther);
};

namespace binding_detail {
struct FastMozStkLocationEvent : public MozStkLocationEvent
{
  inline FastMozStkLocationEvent()
    : MozStkLocationEvent(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkMenu : public DictionaryBase
{
  Optional<uint16_t > mDefaultItem;
  Optional<bool > mIsHelpAvailable;
  Optional<Sequence<MozStkItem > > mItems;
  Optional<Sequence<uint16_t > > mNextActionList;
  Optional<uint16_t > mPresentationType;
  Optional<nsString > mTitle;

  MozStkMenu();

  explicit inline MozStkMenu(const MozStkMenu& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkMenu(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkMenuAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkMenu& aOther);
};

namespace binding_detail {
struct FastMozStkMenu : public MozStkMenu
{
  inline FastMozStkMenu()
    : MozStkMenu(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkPlayTone : public DictionaryBase
{
  MozStkDuration mDuration;
  Optional<bool > mIsVibrate;
  Optional<nsString > mText;
  Optional<uint16_t > mTone;

  MozStkPlayTone();

  explicit inline MozStkPlayTone(const MozStkPlayTone& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkPlayTone(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkPlayToneAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkPlayTone& aOther);
};

namespace binding_detail {
struct FastMozStkPlayTone : public MozStkPlayTone
{
  inline FastMozStkPlayTone()
    : MozStkPlayTone(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkTextMessage : public DictionaryBase
{
  MozStkDuration mDuration;
  Optional<bool > mIsHighPriority;
  Optional<bool > mResponseNeeded;
  Optional<nsString > mText;
  Optional<bool > mUserClear;

  MozStkTextMessage();

  explicit inline MozStkTextMessage(const MozStkTextMessage& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkTextMessage(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkTextMessageAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkTextMessage& aOther);
};

namespace binding_detail {
struct FastMozStkTextMessage : public MozStkTextMessage
{
  inline FastMozStkTextMessage()
    : MozStkTextMessage(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkBrowserSetting : public DictionaryBase
{
  MozStkTextMessage mConfirmMessage;
  Optional<uint16_t > mMode;
  Optional<nsString > mUrl;

  MozStkBrowserSetting();

  explicit inline MozStkBrowserSetting(const MozStkBrowserSetting& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkBrowserSetting(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkBrowserSettingAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkBrowserSetting& aOther);
};

namespace binding_detail {
struct FastMozStkBrowserSetting : public MozStkBrowserSetting
{
  inline FastMozStkBrowserSetting()
    : MozStkBrowserSetting(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkResponse : public DictionaryBase
{
  Optional<bool > mHasConfirmed;
  Optional<nsString > mInput;
  Optional<bool > mIsYesNo;
  Optional<uint16_t > mItemIdentifier;
  MozStkLocalInfo mLocalInfo;
  Optional<uint16_t > mResultCode;
  MozStkTimer mTimer;

  MozStkResponse();

protected:
  explicit inline MozStkResponse(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  MozStkResponse(const MozStkResponse&) MOZ_DELETE;
  void operator=(const MozStkResponse) MOZ_DELETE;

  static bool
  InitIds(JSContext* cx, MozStkResponseAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastMozStkResponse : public MozStkResponse
{
  inline FastMozStkResponse()
    : MozStkResponse(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct MozStkSetUpCall : public DictionaryBase
{
  Optional<nsString > mAddress;
  MozStkTextMessage mCallMessage;
  MozStkTextMessage mConfirmMessage;
  MozStkDuration mDuration;

  MozStkSetUpCall();

  explicit inline MozStkSetUpCall(const MozStkSetUpCall& aOther)
  {
    *this = aOther;
  }

protected:
  explicit inline MozStkSetUpCall(int )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  static bool
  InitIds(JSContext* cx, MozStkSetUpCallAtoms* atomsCache);

public:
  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const MozStkSetUpCall& aOther);
};

namespace binding_detail {
struct FastMozStkSetUpCall : public MozStkSetUpCall
{
  inline FastMozStkSetUpCall()
    : MozStkSetUpCall(42)
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


namespace MozStkCommandEventBinding {

  typedef mozilla::dom::MozStkCommandEvent NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];
  JSObject*
  DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal);

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  JSObject*
  Wrap(JSContext* aCx, JS::Handle<JSObject*> aScope, mozilla::dom::MozStkCommandEvent* aObject, nsWrapperCache* aCache);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JS::Handle<JSObject*> aScope, T* aObject)
  {
    return Wrap(aCx, aScope, aObject, aObject);
  }

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceArray& aProtoAndIfaceArray, bool aDefineOnGlobal);

  JS::Handle<JSObject*>
  GetProtoObject(JSContext* aCx, JS::Handle<JSObject*> aGlobal);

  JS::Handle<JSObject*>
  GetConstructorObject(JSContext* aCx, JS::Handle<JSObject*> aGlobal, bool aDefineOnGlobal = true);

} // namespace MozStkCommandEventBinding



} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_MozStkCommandEventBinding_h__
